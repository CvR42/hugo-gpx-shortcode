<!-- TODO: allow multiple maps to be displayed on the same page -->

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin="" />
<style type="text/css">
  .gpx {
    border: 1px #aaa solid;
    max-width: 100%;
    margin: 1em auto;
  }
  .gpx .map {
    border: 1px #888 solid;
    border-left: none;
    border-right: none;
    width: 100%;
    min-height: 800px;
    margin: 0;
    z-index: 0;
  }
  .gpx footer {
    background: #f0f0f0;
    padding: 0.5em;
  }
  .gpx ul.info {
    list-style: none;
    margin: 0;
    padding: 0;
    font-size: smaller;
  }
  .gpx ul.info li {
    color: #666;
    padding: 2px;
    display: inline;
  }
  .gpx ul.info li span {
    color: black;
  }
  .gpx {
    box-sizing: unset
  }
 .leaflet-container a.location {
    font-size: 1.1rem;
  }
</style>
<script src="/leaflet-src.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.5.0/gpx.min.js"></script>
<section id="container" class="gpx">
  <div class="map" id="map-{{.Get "id" }}"></div>
  <footer>
    {{- $.Scratch.Set "counter" 0 }}
    {{ $len := len .Params }}
    {{ range .Params }}
      <ul class="info">
        {{- $.Scratch.Set "counter" (add ($.Scratch.Get "counter") 1) }}
        <li>{{ if gt $len 1 }}Track {{$.Scratch.Get "counter" }}: {{ end }}</li>
        <li class="start-{{ . }}"></li>
        <li class="distance-{{ . }}"></li>
        <li class="duration-{{ . }}"></li>
        <li class="elevation-{{ . }}"></li>
        <li><a href="{{ . }}">Download</a></li>
      </ul>
    {{ end }}
  </footer>
</section>
<script>
  // TODO the String manipulation feels unnecessary to do in the JS code?
  var urls = "{{ .Params }}".replaceAll('[','').replaceAll(']','').split(' ');
  var mapid = "map-{{.Get "id" }}";
  var container = document.getElementById("container");
  var colors = {{ site.Params.gpx.colors }};
    
  // Create map and layers
  var map = L.map(mapid, { fullscreenControl: true, scrollWheelZoom: false });
  {{ range site.Params.gpx.layers }}
  createLayer({{ .url }}, {{ .attribution | default "" }}, {{ .minZoom | default 1 }}, {{ .maxZoom | default 20}}, {{ .bounds }}, {{ .inverseBounds }}).addTo(map);
  {{ end }}

  var control = L.control.layers(null, null).addTo(map);
  var bounds = null;
  urls.forEach(function(url, index) {
    new L.GPX(url, {
      gpx_options: {
        joinTrackSegments: false
      },
      async: true,
      marker_options: {
        startIconUrl: "/images/pin-icon-start.png",
        endIconUrl: "/images/pin-icon-end.png",
        shadowUrl: "/images/pin-shadow.png",
      },
      // looping through all specified colours
      polyline_options: {color: colors[index % colors.length]}
    }).on("loaded", function(e) {
      var gpx = e.target;
      if (bounds === null) {
        bounds = gpx.getBounds();
      }
      else
      {
        bounds.extend(gpx.getBounds());
      }
      map.fitBounds(bounds);
      control.addOverlay(gpx, gpx.get_name());
      addMetadata(gpx, url);
    }).addTo(map);
  });
  
  // Markers are read from the DOM, e.g. <span class="location" lat="23.50847" lon="120.80161" name="" link="">Alishan Transport Station</span>
  // TODO: The more elegant way would be to pass the markers as parameters to the shortcode.
  document.addEventListener("DOMContentLoaded", function(){
    Array.from(document.getElementsByClassName("location")).forEach(addMarker);
  });
  
  // Create a map layer
  function createLayer(url, attribution, minZoom, maxZoom, bounds, inverseBounds) {
    var layer = L.tileLayer(url, { attribution: attribution, minZoom: minZoom, maxZoom: maxZoom});
    if (bounds != null) {
      // TODO For now, we only support LatLngBounds
      layer.options.bounds = new L.LatLngBounds(
        new L.LatLng(bounds[0], bounds[1]),
        new L.LatLng(bounds[2], bounds[3]));
    }
    if (inverseBounds != null) {
      layer.options.inverseBounds = new L.LatLngBounds(
        new L.LatLng(inverseBounds[0], inverseBounds[1]),
        new L.LatLng(inverseBounds[2], inverseBounds[3]));
    }
    return layer;
  }

  // Add a marker to the map
  function addMarker(link) {
    lat = link.getAttribute("lat");
    lon = link.getAttribute("lon");
    text = link.textContent;
    name = link.getAttribute("name");
    title = (name != "") ? name : text;
    url = link.getAttribute("link");
    if (url != "")
    {
      title = "<a target=\"_blank\" href=\"" + url + "\">" + title + "</a>";
    }
    marker = L.marker([lat, lon]).addTo(map);
    marker.bindPopup(title).openPopup();
  }
  
  // Add metadata to footer
  function addMetadata(gpx, url) {
    var date = gpx.get_start_time();
    var datestring = date.getFullYear() + "-" + (date.getMonth()+1).toString().padStart(2, "0") + "-" + date.getDate().toString().padStart(2, "0")  + " " + date.getHours().toString().padStart(2, "0") + ":" + date.getMinutes().toString().padStart(2, "0");
    _c("start-" + url).textContent = (date > 0) ? datestring : "";
    _c("distance-" + url).textContent = "Distance: " + (gpx.get_distance() / 1000).toFixed(2);
    var duration = gpx.get_moving_time();
    _c("duration-" + url).textContent = (duration > 0) ? "Duration: " + gpx.get_duration_string(duration) : "";
    _c("elevation-"+ url).textContent = `Elevation: ${gpx.get_elevation_gain().toFixed(0)} m, -${gpx.get_elevation_loss().toFixed(0)} m, net:  ${(gpx.get_elevation_gain() - gpx.get_elevation_loss()).toFixed(0)}  m`;
  }
  
  // Helper method to get DOM element by class
  function _c(c) {
    return container.getElementsByClassName(c)[0];
  }
</script>
